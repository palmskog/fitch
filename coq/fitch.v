(* generated by Ott 0.33 from: ott/fitch.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Require Export Structures.OrderedTypeEx.
Require Export FMapInterface.
Require Export Fitch.dyadic_ordered.
Import ListNotations.
Module Fitch (UOT : UsualOrderedType) (DUOT : DyadicUsualOrderedType UOT)
 (Map : FMapInterface.S with Module E := DUOT).
Section FitchProp.
Context {A : Type}.

Definition p : Type := A. (*r atomic proposition *)
Definition l : Type := UOT.t. (*r proof entry label *)
Definition n : Set := nat. (*r index variable (subscript) *)

Inductive justification : Type :=  (*r derivation justification *)
 | justification_premise : justification (*r premise *)
 | justification_lem : justification (*r law of excluded middle *)
 | justification_copy (l5:l) (*r copying *)
 | justification_andi (l5:l) (l':l) (*r conjunction introduction *)
 | justification_ande1 (l5:l) (*r conjunction elimination *)
 | justification_ande2 (l5:l) (*r conjunction elimination *)
 | justification_ori1 (l5:l) (*r disjunction introduction *)
 | justification_ori2 (l5:l) (*r disjunction introduction *)
 | justification_impe (l5:l) (l':l) (*r implication elimination *)
 | justification_nege (l5:l) (l':l) (*r negation elimination *)
 | justification_conte (l5:l) (*r contradiction elimination *)
 | justification_negnegi (l5:l) (*r double negation introduction *)
 | justification_negnege (l5:l) (*r double negation elimination *)
 | justification_mt (l5:l) (l':l) (*r modus tollens *)
 | justification_impi (l5:l) (l':l) (*r implication introduction *)
 | justification_negi (l5:l) (l':l) (*r negation introduction *)
 | justification_ore (l1:l) (l2:l) (l3:l) (l4:l) (l5:l) (*r disjunction elimination *)
 | justification_pbc (l5:l) (l':l) (*r proof by contraduction *).

Inductive reason : Type := 
 | reason_assumption : reason
 | reason_justification (justification5:justification).

Inductive prop : Type :=  (*r proposition *)
 | prop_p (p5:p) (*r atomic *)
 | prop_neg (prop5:prop) (*r negation *)
 | prop_and (prop5:prop) (prop':prop) (*r conjunction *)
 | prop_or (prop5:prop) (prop':prop) (*r disjunction *)
 | prop_imp (prop5:prop) (prop':prop) (*r implication *)
 | prop_cont : prop (*r contradiction *).

Inductive derivation : Type :=  (*r derivation in proof *)
 | derivation_deriv (l5:l) (prop5:prop) (reason5:reason).

Inductive entry : Type :=  (*r proof entry *)
 | entry_derivation (derivation5:derivation) (*r line *)
 | entry_box (_:list entry) (*r box *)
 | entry_invalid : entry.

Definition proplist : Type := list prop.

Definition proof : Type := list entry.

Inductive judgment : Type :=  (*r judgment *)
 | judgment_follows (proplist5:proplist) (prop5:prop).

Definition dyadicprop : Type := (@dyadic prop).

Inductive claim : Type :=  (*r claim *)
 | claim_judgment_proof (judgment5:judgment) (proof5:proof).

Definition G : Type := Map.t dyadicprop.
(** induction principles *)
Section entry_rect.

Variables
  (P_entry : entry -> Prop)
  (P_list_entry : list entry -> Prop).

Hypothesis
  (H_entry_derivation : forall (derivation5:derivation), P_entry (entry_derivation derivation5))
  (H_entry_box : forall (entry_list:list entry), P_list_entry entry_list -> P_entry (entry_box entry_list))
  (H_entry_invalid : P_entry entry_invalid)
  (H_list_entry_nil : P_list_entry nil)
  (H_list_entry_cons : forall (entry0:entry), P_entry entry0 -> forall (entry_l:list entry), P_list_entry entry_l -> P_list_entry (cons entry0 entry_l)).

Fixpoint entry_ott_ind (n:entry) : P_entry n :=
  match n as x return P_entry x with
  | (entry_derivation derivation5) => H_entry_derivation derivation5
  | (entry_box entry_list) => H_entry_box entry_list (((fix entry_list_ott_ind (entry_l:list entry) : P_list_entry entry_l := match entry_l as x return P_list_entry x with nil => H_list_entry_nil | cons entry1 xl => H_list_entry_cons entry1(entry_ott_ind entry1)xl (entry_list_ott_ind xl) end)) entry_list)
  | entry_invalid => H_entry_invalid 
end.

End entry_rect.
(** definitions *)

(* defns validity *)
Inductive valid_claim : claim -> Prop :=    (* defn valid_claim *)
 | vc_claim : forall (proplist5:proplist) (prop5:prop) (proof5:proof) (l5:l) (justification5:justification),
       (last ( proof5 ) entry_invalid)   =  (entry_derivation (derivation_deriv l5 prop5 (reason_justification justification5)))  ->
     valid_proof  (Map.empty dyadicprop)  proplist5 proof5 ->
     valid_claim (claim_judgment_proof (judgment_follows proplist5 prop5) proof5)
with valid_proof : G -> proplist -> proof -> Prop :=    (* defn valid_proof *)
 | vp_empty : forall (G5:G) (proplist5:proplist),
     valid_proof G5 proplist5  [] 
 | vp_derivation : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (justification5:justification) (proof5:proof),
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification justification5)) ->
     valid_proof  (Map.add (inl  l5 ) (inl  prop5 )  G5 )  proplist5 proof5 ->
     valid_proof G5 proplist5  ( (entry_derivation (derivation_deriv l5 prop5 (reason_justification justification5)))  ::  proof5 ) 
 | vp_box : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (proof5 proof':proof) (l':l) (prop':prop) (reason5:reason),
       (last (  ( (entry_derivation (derivation_deriv l5 prop5 reason_assumption))  ::  proof5 )  ) entry_invalid)   =  (entry_derivation (derivation_deriv l' prop' reason5))  ->
     valid_proof  (Map.add (inl  l5 ) (inl  prop5 )  G5 )  proplist5 proof5 ->
     valid_proof  (Map.add (inr ( l5 ,  l' )) (inr ( prop5 ,  prop' ))  G5 )  proplist5 proof' ->
     valid_proof G5 proplist5  (  (entry_box   ( (entry_derivation (derivation_deriv l5 prop5 reason_assumption))  ::  proof5 )  )   ::  proof' ) 
with valid_derivation : G -> proplist -> derivation -> Prop :=    (* defn valid_derivation *)
 | vd_premise : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop),
      (In  prop5   proplist5 )  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification justification_premise))
 | vd_lem : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop),
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 (prop_neg prop5)) (reason_justification justification_lem))
 | vd_copy : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_copy l')))
 | vd_conte : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  prop_cont ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_conte l')))
 | vd_andi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5 prop':prop) (l1 l2:l),
      (Map.find (inl  l1 )  G5  = Some (inl  prop5 ))  ->
      (Map.find (inl  l2 )  G5  = Some (inl  prop' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_and prop5 prop') (reason_justification (justification_andi l1 l2)))
 | vd_ande1 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l) (prop':prop),
      (Map.find (inl  l' )  G5  = Some (inl  (prop_and prop5 prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_ande1 l')))
 | vd_ande2 : forall (G5:G) (proplist5:proplist) (l5:l) (prop':prop) (l':l) (prop5:prop),
      (Map.find (inl  l' )  G5  = Some (inl  (prop_and prop5 prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop' (reason_justification (justification_ande2 l')))
 | vd_ori1 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5 prop':prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 prop') (reason_justification (justification_ori1 l')))
 | vd_ori2 : forall (G5:G) (proplist5:proplist) (l5:l) (prop5 prop':prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  prop' ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_or prop5 prop') (reason_justification (justification_ori2 l')))
 | vd_impe : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l) (prop':prop),
      (Map.find (inl  l1 )  G5  = Some (inl  prop' ))  ->
      (Map.find (inl  l2 )  G5  = Some (inl  (prop_imp prop' prop5) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop5 (reason_justification (justification_impe l1 l2)))
 | vd_negnegi : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  prop5 ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 (prop_neg (prop_neg prop5)) (reason_justification (justification_negnegi l')))
 | vd_negnege : forall (G5:G) (proplist5:proplist) (l5:l) (prop5:prop) (l':l),
      (Map.find (inl  l' )  G5  = Some (inl  (prop_neg (prop_neg prop5)) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l5 prop5 (reason_justification (justification_negnege l')))
 | vd_mt : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l) (prop':prop),
      (Map.find (inl  l1 )  G5  = Some (inl  (prop_imp prop5 prop') ))  ->
      (Map.find (inl  l2 )  G5  = Some (inl  (prop_neg prop') ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_neg prop5) (reason_justification (justification_mt l1 l2)))
 | vd_nege : forall (G5:G) (proplist5:proplist) (l_5 l1 l2:l) (prop5:prop),
      (Map.find (inl  l1 )  G5  = Some (inl  prop5 ))  ->
      (Map.find (inl  l2 )  G5  = Some (inl  (prop_neg prop5) ))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop_cont (reason_justification (justification_nege l1 l2)))
 | vd_impi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5 prop':prop) (l1 l2:l),
      (Map.find (inr ( l1 ,  l2 ))  G5  = Some (inr ( prop5 ,  prop' )))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_imp prop5 prop') (reason_justification (justification_impi l1 l2)))
 | vd_negi : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l),
      (Map.find (inr ( l1 ,  l2 ))  G5  = Some (inr ( prop5 ,  prop_cont )))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 (prop_neg prop5) (reason_justification (justification_negi l1 l2)))
 | vd_ore : forall (G5:G) (proplist5:proplist) (l_6:l) (prop'':prop) (l1 l2 l3 l4 l5:l) (prop5 prop':prop),
      (Map.find (inl  l1 )  G5  = Some (inl  (prop_or prop5 prop') ))  ->
      (Map.find (inr ( l2 ,  l3 ))  G5  = Some (inr ( prop5 ,  prop'' )))  ->
      (Map.find (inr ( l4 ,  l5 ))  G5  = Some (inr ( prop' ,  prop'' )))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_6 prop'' (reason_justification (justification_ore l1 l2 l3 l4 l5)))
 | vd_pbc : forall (G5:G) (proplist5:proplist) (l_5:l) (prop5:prop) (l1 l2:l),
      (Map.find (inr ( l1 ,  l2 ))  G5  = Some (inr ( (prop_neg prop5) ,  prop_cont )))  ->
     valid_derivation G5 proplist5 (derivation_deriv l_5 prop5 (reason_justification (justification_pbc l1 l2))).
End FitchProp.
End Fitch.



